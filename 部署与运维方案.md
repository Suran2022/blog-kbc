# 博客项目部署与运维方案

## 一、概述

本文档详细描述了博客系统的部署与运维方案，包括部署架构、环境配置、部署流程、监控策略、备份恢复、安全防护以及性能优化等内容。通过系统化的部署与运维措施，确保博客系统的稳定运行、高可用性和良好的用户体验。

## 二、部署架构

### 2.1 整体架构

博客系统采用前后端分离的架构，部署架构如下：

```
用户 --> CDN --> Nginx(前端静态资源) --> Spring Boot应用(后端API) --> MySQL数据库
                                                  |
                                                  v
                                                Redis缓存
```

### 2.2 部署环境

#### 2.2.1 开发环境

- 前端：本地开发服务器（localhost:8080）
- 后端：本地开发服务器（localhost:8081）
- 数据库：本地MySQL（localhost:3306）
- 缓存：本地Redis（localhost:6379）

#### 2.2.2 测试环境

- 服务器配置：2核4G内存，50G SSD
- 操作系统：CentOS 7.9
- 前端：Nginx 1.20
- 后端：Spring Boot 2.5.x（JDK 11）
- 数据库：MySQL 8.0
- 缓存：Redis 6.0

#### 2.2.3 生产环境

- 服务器配置：4核8G内存，100G SSD
- 操作系统：CentOS 7.9
- 前端：Nginx 1.20 + CDN
- 后端：Spring Boot 2.5.x（JDK 11）
- 数据库：MySQL 8.0（主从复制）
- 缓存：Redis 6.0（哨兵模式）

### 2.3 网络架构

#### 2.3.1 生产环境网络架构

```
互联网 --> 防火墙 --> 负载均衡器 --> Web服务器集群 --> 应用服务器集群 --> 数据库集群
                                                                  |
                                                                  v
                                                              缓存集群
```

#### 2.3.2 网络安全配置

- 使用防火墙限制服务器访问
- 仅开放必要端口（80、443、22等）
- 使用VPN或内网穿透工具进行远程管理
- 配置Web应用防火墙（WAF）防御常见Web攻击

## 三、环境配置

### 3.1 服务器基础配置

#### 3.1.1 系统优化

```bash
# 更新系统
yum update -y

# 安装常用工具
yum install -y vim wget curl net-tools lsof

# 配置时区
timedatectl set-timezone Asia/Shanghai

# 安装NTP服务
yum install -y chrony
systemctl enable chronyd
systemctl start chronyd

# 优化内核参数
cat > /etc/sysctl.conf << EOF
# 最大文件句柄数
fs.file-max = 1000000
# TCP连接参数
net.ipv4.tcp_max_tw_buckets = 6000
net.ipv4.tcp_sack = 1
net.ipv4.tcp_window_scaling = 1
net.ipv4.tcp_rmem = 4096 87380 4194304
net.ipv4.tcp_wmem = 4096 16384 4194304
net.ipv4.tcp_max_syn_backlog = 16384
net.core.netdev_max_backlog = 32768
net.core.somaxconn = 32768
net.core.wmem_default = 8388608
net.core.rmem_default = 8388608
net.core.rmem_max = 16777216
net.core.wmem_max = 16777216
net.ipv4.tcp_timestamps = 0
net.ipv4.tcp_fin_timeout = 20
nnet.ipv4.tcp_synack_retries = 2
net.ipv4.tcp_syn_retries = 2
net.ipv4.tcp_syncookies = 1
# 关闭ipv6
net.ipv6.conf.all.disable_ipv6 = 1
net.ipv6.conf.default.disable_ipv6 = 1
# 开启端口重用
net.ipv4.tcp_tw_reuse = 1
EOF

# 应用内核参数
sysctl -p

# 优化系统限制
cat > /etc/security/limits.conf << EOF
* soft nofile 65536
* hard nofile 65536
* soft nproc 65536
* hard nproc 65536
EOF
```

#### 3.1.2 安装Docker

```bash
# 安装依赖
yum install -y yum-utils device-mapper-persistent-data lvm2

# 添加Docker仓库
yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo

# 安装Docker
yum install -y docker-ce docker-ce-cli containerd.io

# 启动Docker
systemctl enable docker
systemctl start docker

# 安装Docker Compose
curl -L "https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
chmod +x /usr/local/bin/docker-compose
```

### 3.2 应用环境配置

#### 3.2.1 Nginx配置

```bash
# 安装Nginx
yum install -y nginx

# 配置Nginx
cat > /etc/nginx/conf.d/blog.conf << EOF
server {
    listen 80;
    server_name blog.example.com;
    
    # 重定向到HTTPS
    return 301 https://\$host\$request_uri;
}

server {
    listen 443 ssl http2;
    server_name blog.example.com;
    
    # SSL配置
    ssl_certificate /etc/nginx/ssl/blog.example.com.crt;
    ssl_certificate_key /etc/nginx/ssl/blog.example.com.key;
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers HIGH:!aNULL:!MD5;
    ssl_prefer_server_ciphers on;
    ssl_session_cache shared:SSL:10m;
    ssl_session_timeout 10m;
    
    # 前端静态资源
    location / {
        root /var/www/blog;
        index index.html;
        try_files \$uri \$uri/ /index.html;
        
        # 缓存配置
        expires 7d;
        add_header Cache-Control "public, max-age=604800";
    }
    
    # API请求代理
    location /api/ {
        proxy_pass http://backend;
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
        
        # 超时配置
        proxy_connect_timeout 60s;
        proxy_read_timeout 60s;
        proxy_send_timeout 60s;
    }
    
    # 静态资源缓存配置
    location ~* \.(jpg|jpeg|png|gif|ico|css|js)\$ {
        root /var/www/blog;
        expires 30d;
        add_header Cache-Control "public, max-age=2592000";
    }
    
    # 日志配置
    access_log /var/log/nginx/blog.access.log;
    error_log /var/log/nginx/blog.error.log;
}

# 后端服务器组
upstream backend {
    server 127.0.0.1:8081 weight=1 max_fails=3 fail_timeout=30s;
    # 如果有多台后端服务器，可以添加多个server配置
    # server 127.0.0.1:8082 weight=1 max_fails=3 fail_timeout=30s;
}
EOF

# 启动Nginx
systemctl enable nginx
systemctl start nginx
```

#### 3.2.2 MySQL配置

```bash
# 安装MySQL
yum install -y https://dev.mysql.com/get/mysql80-community-release-el7-3.noarch.rpm
yum install -y mysql-community-server

# 启动MySQL
systemctl enable mysqld
systemctl start mysqld

# 获取临时密码
temp_password=$(grep 'temporary password' /var/log/mysqld.log | awk '{print $NF}')

# 配置MySQL
mysql_secure_installation

# 创建数据库和用户
mysql -uroot -p << EOF
CREATE DATABASE blog CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
CREATE USER 'bloguser'@'%' IDENTIFIED BY 'StrongPassword123!';
GRANT ALL PRIVILEGES ON blog.* TO 'bloguser'@'%';
FLUSH PRIVILEGES;
EOF

# 优化MySQL配置
cat > /etc/my.cnf.d/mysql-optimization.cnf << EOF
[mysqld]
# 基础配置
character-set-server = utf8mb4
collation-server = utf8mb4_unicode_ci
default-authentication-plugin = mysql_native_password

# 连接数配置
max_connections = 1000
max_connect_errors = 1000
back_log = 128

# 缓冲区配置
innodb_buffer_pool_size = 1G
innodb_log_buffer_size = 16M
join_buffer_size = 1M
sort_buffer_size = 2M
read_buffer_size = 1M
read_rnd_buffer_size = 1M

# 日志配置
slow_query_log = 1
slow_query_log_file = /var/log/mysql/mysql-slow.log
long_query_time = 2
log_error = /var/log/mysql/mysql-error.log

# InnoDB配置
innodb_file_per_table = 1
innodb_flush_log_at_trx_commit = 2
innodb_flush_method = O_DIRECT
innodb_io_capacity = 200
EOF

# 重启MySQL
systemctl restart mysqld
```

#### 3.2.3 Redis配置

```bash
# 安装Redis
yum install -y redis

# 配置Redis
cat > /etc/redis.conf << EOF
# 基础配置
bind 127.0.0.1
protected-mode yes
port 6379
tcp-backlog 511
timeout 0
tcp-keepalive 300
daemonize yes
supervised systemd
pidfile /var/run/redis_6379.pid
loglevel notice
logfile /var/log/redis/redis.log

# 内存配置
maxmemory 1gb
maxmemory-policy allkeys-lru

# 持久化配置
save 900 1
save 300 10
save 60 10000
stop-writes-on-bgsave-error yes
rdbcompression yes
rdbchecksum yes
dbfilename dump.rdb
dir /var/lib/redis

# 安全配置
requirepass StrongRedisPassword123!
EOF

# 启动Redis
systemctl enable redis
systemctl start redis
```

### 3.3 Docker部署配置

#### 3.3.1 Docker Compose配置

```yaml
# docker-compose.yml
version: '3'

services:
  # 前端服务
  frontend:
    image: nginx:1.20
    container_name: blog-frontend
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx/conf.d:/etc/nginx/conf.d
      - ./nginx/ssl:/etc/nginx/ssl
      - ./frontend/dist:/var/www/blog
      - ./nginx/logs:/var/log/nginx
    depends_on:
      - backend
    restart: always
    networks:
      - blog-network

  # 后端服务
  backend:
    image: openjdk:11-jre
    container_name: blog-backend
    ports:
      - "8081:8081"
    volumes:
      - ./backend/app.jar:/app/app.jar
      - ./backend/logs:/app/logs
      - ./backend/config:/app/config
    environment:
      - SPRING_PROFILES_ACTIVE=prod
      - JAVA_OPTS=-Xms512m -Xmx1024m -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=256m
    command: java ${JAVA_OPTS} -jar /app/app.jar --spring.config.location=file:/app/config/application-prod.yml
    depends_on:
      - mysql
      - redis
    restart: always
    networks:
      - blog-network

  # MySQL服务
  mysql:
    image: mysql:8.0
    container_name: blog-mysql
    ports:
      - "3306:3306"
    volumes:
      - ./mysql/data:/var/lib/mysql
      - ./mysql/conf:/etc/mysql/conf.d
      - ./mysql/logs:/var/log/mysql
    environment:
      - MYSQL_ROOT_PASSWORD=StrongRootPassword123!
      - MYSQL_DATABASE=blog
      - MYSQL_USER=bloguser
      - MYSQL_PASSWORD=StrongPassword123!
    restart: always
    networks:
      - blog-network

  # Redis服务
  redis:
    image: redis:6.0
    container_name: blog-redis
    ports:
      - "6379:6379"
    volumes:
      - ./redis/data:/data
      - ./redis/redis.conf:/usr/local/etc/redis/redis.conf
    command: redis-server /usr/local/etc/redis/redis.conf
    restart: always
    networks:
      - blog-network

networks:
  blog-network:
    driver: bridge
```

## 四、部署流程

### 4.1 前端部署流程

#### 4.1.1 构建前端项目

```bash
# 进入前端项目目录
cd blog-frontend

# 安装依赖
npm install

# 构建生产环境代码
npm run build

# 将构建产物复制到部署目录
mkdir -p /var/www/blog
cp -r dist/* /var/www/blog/
```

#### 4.1.2 部署到Nginx

```bash
# 配置Nginx（如果使用上面的配置文件，此步骤可跳过）

# 检查Nginx配置
nginx -t

# 重新加载Nginx配置
systemctl reload nginx
```

### 4.2 后端部署流程

#### 4.2.1 构建后端项目

```bash
# 进入后端项目目录
cd blog-backend

# 使用Maven构建项目
mvn clean package -DskipTests

# 将构建产物复制到部署目录
mkdir -p /opt/blog/backend
cp target/blog-backend.jar /opt/blog/backend/app.jar
cp -r src/main/resources/application-prod.yml /opt/blog/backend/
```

#### 4.2.2 配置后端服务

```bash
# 创建服务配置文件
cat > /etc/systemd/system/blog-backend.service << EOF
[Unit]
Description=Blog Backend Service
After=network.target mysql.service redis.service

[Service]
Type=simple
User=root
WorkingDirectory=/opt/blog/backend
ExecStart=/usr/bin/java -Xms512m -Xmx1024m -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=256m -jar /opt/blog/backend/app.jar --spring.config.location=file:/opt/blog/backend/application-prod.yml
Restart=always
RestartSec=10

[Install]
WantedBy=multi-user.target
EOF

# 启动服务
systemctl daemon-reload
systemctl enable blog-backend
systemctl start blog-backend
```

### 4.3 Docker部署流程

```bash
# 创建部署目录
mkdir -p /opt/blog/{frontend,backend,mysql,redis,nginx/{conf.d,ssl,logs}}

# 复制Docker Compose配置文件
cp docker-compose.yml /opt/blog/

# 复制前端构建产物
cp -r blog-frontend/dist/* /opt/blog/frontend/

# 复制后端构建产物
cp blog-backend/target/blog-backend.jar /opt/blog/backend/app.jar
cp blog-backend/src/main/resources/application-prod.yml /opt/blog/backend/config/

# 复制Nginx配置文件
cp nginx/conf.d/blog.conf /opt/blog/nginx/conf.d/

# 复制SSL证书（如果有）
cp nginx/ssl/* /opt/blog/nginx/ssl/

# 复制Redis配置文件
cp redis/redis.conf /opt/blog/redis/

# 启动服务
cd /opt/blog
docker-compose up -d
```

### 4.4 CI/CD自动化部署

#### 4.4.1 Jenkins Pipeline配置

```groovy
pipeline {
    agent any
    
    stages {
        stage('Checkout') {
            steps {
                checkout scm
            }
        }
        
        stage('Build Backend') {
            steps {
                dir('blog-backend') {
                    sh 'mvn clean package -DskipTests'
                }
            }
        }
        
        stage('Build Frontend') {
            steps {
                dir('blog-frontend') {
                    sh 'npm install'
                    sh 'npm run build'
                }
            }
        }
        
        stage('Deploy to Test') {
            when {
                branch 'develop'
            }
            steps {
                sshagent(['test-server']) {
                    sh '''
                        ssh user@test-server "mkdir -p /opt/blog/backend /opt/blog/frontend"
                        scp blog-backend/target/blog-backend.jar user@test-server:/opt/blog/backend/app.jar
                        scp blog-backend/src/main/resources/application-test.yml user@test-server:/opt/blog/backend/application-prod.yml
                        scp -r blog-frontend/dist/* user@test-server:/opt/blog/frontend/
                        ssh user@test-server "systemctl restart blog-backend"
                        ssh user@test-server "systemctl reload nginx"
                    '''
                }
            }
        }
        
        stage('Deploy to Production') {
            when {
                branch 'master'
            }
            steps {
                input message: 'Deploy to production?', ok: 'Yes'
                sshagent(['prod-server']) {
                    sh '''
                        ssh user@prod-server "mkdir -p /opt/blog/backend /opt/blog/frontend"
                        scp blog-backend/target/blog-backend.jar user@prod-server:/opt/blog/backend/app.jar
                        scp blog-backend/src/main/resources/application-prod.yml user@prod-server:/opt/blog/backend/application-prod.yml
                        scp -r blog-frontend/dist/* user@prod-server:/opt/blog/frontend/
                        ssh user@prod-server "systemctl restart blog-backend"
                        ssh user@prod-server "systemctl reload nginx"
                    '''
                }
            }
        }
    }
    
    post {
        always {
            emailext body: '${DEFAULT_CONTENT}',
                     subject: '${DEFAULT_SUBJECT}',
                     to: 'team@example.com'
        }
    }
}
```

## 五、监控与告警

### 5.1 系统监控

#### 5.1.1 Prometheus + Grafana监控方案

```yaml
# docker-compose-monitoring.yml
version: '3'

services:
  prometheus:
    image: prom/prometheus:v2.30.0
    container_name: prometheus
    ports:
      - "9090:9090"
    volumes:
      - ./prometheus/prometheus.yml:/etc/prometheus/prometheus.yml
      - prometheus_data:/prometheus
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
      - '--web.console.libraries=/usr/share/prometheus/console_libraries'
      - '--web.console.templates=/usr/share/prometheus/consoles'
    restart: always
    networks:
      - monitoring-network

  grafana:
    image: grafana/grafana:8.2.0
    container_name: grafana
    ports:
      - "3000:3000"
    volumes:
      - grafana_data:/var/lib/grafana
      - ./grafana/provisioning:/etc/grafana/provisioning
    environment:
      - GF_SECURITY_ADMIN_USER=admin
      - GF_SECURITY_ADMIN_PASSWORD=StrongGrafanaPassword123!
      - GF_USERS_ALLOW_SIGN_UP=false
    restart: always
    networks:
      - monitoring-network

  node-exporter:
    image: prom/node-exporter:v1.2.2
    container_name: node-exporter
    ports:
      - "9100:9100"
    volumes:
      - /proc:/host/proc:ro
      - /sys:/host/sys:ro
      - /:/rootfs:ro
    command:
      - '--path.procfs=/host/proc'
      - '--path.sysfs=/host/sys'
      - '--path.rootfs=/rootfs'
      - '--collector.filesystem.ignored-mount-points=^/(sys|proc|dev|host|etc)($$|/)'
    restart: always
    networks:
      - monitoring-network

  cadvisor:
    image: gcr.io/google-containers/cadvisor:v0.39.0
    container_name: cadvisor
    ports:
      - "8080:8080"
    volumes:
      - /:/rootfs:ro
      - /var/run:/var/run:ro
      - /sys:/sys:ro
      - /var/lib/docker/:/var/lib/docker:ro
      - /dev/disk/:/dev/disk:ro
    restart: always
    networks:
      - monitoring-network

volumes:
  prometheus_data:
  grafana_data:

networks:
  monitoring-network:
    driver: bridge
```

#### 5.1.2 Prometheus配置

```yaml
# prometheus.yml
global:
  scrape_interval: 15s
  evaluation_interval: 15s

alerting:
  alertmanagers:
    - static_configs:
        - targets:
          - alertmanager:9093

rule_files:
  - "alert_rules.yml"

scrape_configs:
  - job_name: 'prometheus'
    static_configs:
      - targets: ['localhost:9090']

  - job_name: 'node-exporter'
    static_configs:
      - targets: ['node-exporter:9100']

  - job_name: 'cadvisor'
    static_configs:
      - targets: ['cadvisor:8080']

  - job_name: 'spring-boot'
    metrics_path: '/actuator/prometheus'
    static_configs:
      - targets: ['backend:8081']

  - job_name: 'mysql'
    static_configs:
      - targets: ['mysql-exporter:9104']

  - job_name: 'redis'
    static_configs:
      - targets: ['redis-exporter:9121']

  - job_name: 'nginx'
    static_configs:
      - targets: ['nginx-exporter:9113']
```

#### 5.1.3 告警规则配置

```yaml
# alert_rules.yml
groups:
  - name: blog_alerts
    rules:
      - alert: HighCPULoad
        expr: 100 - (avg by(instance) (irate(node_cpu_seconds_total{mode="idle"}[5m])) * 100) > 80
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "High CPU load (instance {{ $labels.instance }})"
          description: "CPU load is > 80%\n  VALUE = {{ $value }}\n  LABELS: {{ $labels }}"

      - alert: HighMemoryLoad
        expr: (node_memory_MemTotal_bytes - node_memory_MemFree_bytes - node_memory_Buffers_bytes - node_memory_Cached_bytes) / node_memory_MemTotal_bytes * 100 > 80
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "High memory load (instance {{ $labels.instance }})"
          description: "Memory load is > 80%\n  VALUE = {{ $value }}\n  LABELS: {{ $labels }}"

      - alert: HighDiskUsage
        expr: (node_filesystem_size_bytes{fstype!="tmpfs"} - node_filesystem_free_bytes{fstype!="tmpfs"}) / node_filesystem_size_bytes{fstype!="tmpfs"} * 100 > 80
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "High disk usage (instance {{ $labels.instance }})"
          description: "Disk usage is > 80%\n  VALUE = {{ $value }}\n  LABELS: {{ $labels }}"

      - alert: InstanceDown
        expr: up == 0
        for: 5m
        labels:
          severity: critical
        annotations:
          summary: "Instance down (instance {{ $labels.instance }})"
          description: "Instance has been down for more than 5 minutes\n  VALUE = {{ $value }}\n  LABELS: {{ $labels }}"

      - alert: APIHighResponseTime
        expr: histogram_quantile(0.95, sum(rate(http_server_requests_seconds_bucket{job="spring-boot"}[5m])) by (le, uri)) > 1
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "API high response time (instance {{ $labels.instance }})"
          description: "API response time is > 1s (95th percentile)\n  VALUE = {{ $value }}\n  LABELS: {{ $labels }}"
```

### 5.2 日志管理

#### 5.2.1 ELK日志方案

```yaml
# docker-compose-elk.yml
version: '3'

services:
  elasticsearch:
    image: docker.elastic.co/elasticsearch/elasticsearch:7.14.0
    container_name: elasticsearch
    environment:
      - discovery.type=single-node
      - "ES_JAVA_OPTS=-Xms512m -Xmx512m"
    ulimits:
      memlock:
        soft: -1
        hard: -1
    volumes:
      - elasticsearch_data:/usr/share/elasticsearch/data
    ports:
      - "9200:9200"
    networks:
      - elk-network

  logstash:
    image: docker.elastic.co/logstash/logstash:7.14.0
    container_name: logstash
    volumes:
      - ./logstash/pipeline:/usr/share/logstash/pipeline
      - ./logstash/config/logstash.yml:/usr/share/logstash/config/logstash.yml
    ports:
      - "5044:5044"
      - "5000:5000/tcp"
      - "5000:5000/udp"
      - "9600:9600"
    environment:
      LS_JAVA_OPTS: "-Xmx256m -Xms256m"
    networks:
      - elk-network
    depends_on:
      - elasticsearch

  kibana:
    image: docker.elastic.co/kibana/kibana:7.14.0
    container_name: kibana
    ports:
      - "5601:5601"
    environment:
      ELASTICSEARCH_URL: http://elasticsearch:9200
      ELASTICSEARCH_HOSTS: http://elasticsearch:9200
    networks:
      - elk-network
    depends_on:
      - elasticsearch

  filebeat:
    image: docker.elastic.co/beats/filebeat:7.14.0
    container_name: filebeat
    volumes:
      - ./filebeat/filebeat.yml:/usr/share/filebeat/filebeat.yml:ro
      - /var/log:/var/log:ro
      - /var/lib/docker/containers:/var/lib/docker/containers:ro
    networks:
      - elk-network
    depends_on:
      - elasticsearch
      - logstash

volumes:
  elasticsearch_data:

networks:
  elk-network:
    driver: bridge
```

#### 5.2.2 Filebeat配置

```yaml
# filebeat.yml
filebeat.inputs:
- type: log
  enabled: true
  paths:
    - /var/log/nginx/*.log
  fields:
    type: nginx

- type: log
  enabled: true
  paths:
    - /opt/blog/backend/logs/*.log
  fields:
    type: application

- type: container
  enabled: true
  paths:
    - /var/lib/docker/containers/*/*.log

processors:
- add_docker_metadata: ~
- add_host_metadata: ~

output.logstash:
  hosts: ["logstash:5044"]
```

#### 5.2.3 Logstash配置

```conf
# logstash.conf
input {
  beats {
    port => 5044
  }
}

filter {
  if [fields][type] == "nginx" {
    grok {
      match => { "message" => "%{IPORHOST:remote_ip} - %{DATA:user_name} \[%{HTTPDATE:time}\] \"%{WORD:method} %{DATA:url} HTTP/%{NUMBER:http_version}\" %{NUMBER:response_code} %{NUMBER:body_sent_bytes} \"%{DATA:referrer}\" \"%{DATA:agent}\"" }
    }
  }
  
  if [fields][type] == "application" {
    grok {
      match => { "message" => "%{TIMESTAMP_ISO8601:timestamp}\s+%{LOGLEVEL:level}\s+%{DATA:thread}\s+%{DATA:class}\s+\[%{DATA:context}\]\s+%{GREEDYDATA:message}" }
    }
  }
}

output {
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "%{[fields][type]}-%{+YYYY.MM.dd}"
  }
}
```

## 六、备份与恢复

### 6.1 数据库备份

#### 6.1.1 MySQL自动备份脚本

```bash
#!/bin/bash

# 配置信息
BACKUP_DIR="/backup/mysql"
MYSQL_USER="root"
MYSQL_PASSWORD="StrongRootPassword123!"
DATABASE="blog"
DATE=$(date +"%Y%m%d-%H%M%S")
BACKUP_FILE="${BACKUP_DIR}/${DATABASE}-${DATE}.sql.gz"
LOG_FILE="/var/log/mysql-backup.log"
RETENTION_DAYS=7

# 创建备份目录
mkdir -p ${BACKUP_DIR}

# 记录开始时间
echo "$(date) - Starting backup of ${DATABASE}" >> ${LOG_FILE}

# 执行备份
mysqldump -u${MYSQL_USER} -p${MYSQL_PASSWORD} --single-transaction --quick --lock-tables=false ${DATABASE} | gzip > ${BACKUP_FILE}

# 检查备份是否成功
if [ $? -eq 0 ]; then
    echo "$(date) - Backup completed successfully: ${BACKUP_FILE}" >> ${LOG_FILE}
    
    # 删除旧备份
    find ${BACKUP_DIR} -name "${DATABASE}-*.sql.gz" -type f -mtime +${RETENTION_DAYS} -delete
    echo "$(date) - Deleted backups older than ${RETENTION_DAYS} days" >> ${LOG_FILE}
else
    echo "$(date) - Backup failed!" >> ${LOG_FILE}
fi
```

#### 6.1.2 设置定时任务

```bash
# 编辑crontab
crontab -e

# 添加定时任务（每天凌晨2点执行备份）
0 2 * * * /path/to/mysql-backup.sh
```

### 6.2 文件备份

#### 6.2.1 文件自动备份脚本

```bash
#!/bin/bash

# 配置信息
BACKUP_DIR="/backup/files"
SOURCE_DIR="/var/www/blog"
DATE=$(date +"%Y%m%d-%H%M%S")
BACKUP_FILE="${BACKUP_DIR}/blog-files-${DATE}.tar.gz"
LOG_FILE="/var/log/files-backup.log"
RETENTION_DAYS=7

# 创建备份目录
mkdir -p ${BACKUP_DIR}

# 记录开始时间
echo "$(date) - Starting backup of ${SOURCE_DIR}" >> ${LOG_FILE}

# 执行备份
tar -czf ${BACKUP_FILE} -C $(dirname ${SOURCE_DIR}) $(basename ${SOURCE_DIR})

# 检查备份是否成功
if [ $? -eq 0 ]; then
    echo "$(date) - Backup completed successfully: ${BACKUP_FILE}" >> ${LOG_FILE}
    
    # 删除旧备份
    find ${BACKUP_DIR} -name "blog-files-*.tar.gz" -type f -mtime +${RETENTION_DAYS} -delete
    echo "$(date) - Deleted backups older than ${RETENTION_DAYS} days" >> ${LOG_FILE}
else
    echo "$(date) - Backup failed!" >> ${LOG_FILE}
fi
```

#### 6.2.2 设置定时任务

```bash
# 编辑crontab
crontab -e

# 添加定时任务（每周日凌晨3点执行备份）
0 3 * * 0 /path/to/files-backup.sh
```

### 6.3 备份到远程存储

#### 6.3.1 备份到S3存储

```bash
#!/bin/bash

# 配置信息
LOCAL_BACKUP_DIR="/backup"
S3_BUCKET="s3://my-blog-backups"
AWS_PROFILE="backup-profile"
LOG_FILE="/var/log/s3-backup.log"

# 记录开始时间
echo "$(date) - Starting S3 backup sync" >> ${LOG_FILE}

# 同步到S3
aws s3 sync ${LOCAL_BACKUP_DIR} ${S3_BUCKET} --profile ${AWS_PROFILE}

# 检查同步是否成功
if [ $? -eq 0 ]; then
    echo "$(date) - S3 sync completed successfully" >> ${LOG_FILE}
else
    echo "$(date) - S3 sync failed!" >> ${LOG_FILE}
fi
```

### 6.4 数据恢复

#### 6.4.1 MySQL数据恢复

```bash
#!/bin/bash

# 配置信息
BACKUP_FILE=$1
MYSQL_USER="root"
MYSQL_PASSWORD="StrongRootPassword123!"
DATABASE="blog"
LOG_FILE="/var/log/mysql-restore.log"

# 检查备份文件是否存在
if [ ! -f ${BACKUP_FILE} ]; then
    echo "$(date) - Backup file not found: ${BACKUP_FILE}" >> ${LOG_FILE}
    exit 1
fi

# 记录开始时间
echo "$(date) - Starting restore of ${DATABASE} from ${BACKUP_FILE}" >> ${LOG_FILE}

# 执行恢复
gunzip -c ${BACKUP_FILE} | mysql -u${MYSQL_USER} -p${MYSQL_PASSWORD} ${DATABASE}

# 检查恢复是否成功
if [ $? -eq 0 ]; then
    echo "$(date) - Restore completed successfully" >> ${LOG_FILE}
else
    echo "$(date) - Restore failed!" >> ${LOG_FILE}
fi
```

## 七、安全防护

### 7.1 服务器安全加固

#### 7.1.1 SSH安全配置

```bash
# 编辑SSH配置文件
vi /etc/ssh/sshd_config

# 修改以下配置
Port 22222                  # 修改默认SSH端口
PermitRootLogin no          # 禁止root直接登录
PasswordAuthentication no   # 禁用密码认证，只允许密钥认证
PubkeyAuthentication yes    # 启用公钥认证
AllowUsers username         # 只允许特定用户登录

# 重启SSH服务
systemctl restart sshd
```

#### 7.1.2 防火墙配置

```bash
# 安装防火墙
yum install -y firewalld

# 启动防火墙
systemctl enable firewalld
systemctl start firewalld

# 配置防火墙规则
firewall-cmd --permanent --add-service=http
firewall-cmd --permanent --add-service=https
firewall-cmd --permanent --add-port=22222/tcp  # SSH端口
firewall-cmd --permanent --add-port=3306/tcp   # MySQL端口（如果需要远程访问）
firewall-cmd --permanent --add-port=6379/tcp   # Redis端口（如果需要远程访问）

# 重新加载防火墙配置
firewall-cmd --reload
```

#### 7.1.3 安装Fail2ban防暴力破解

```bash
# 安装Fail2ban
yum install -y epel-release
yum install -y fail2ban

# 配置Fail2ban
cat > /etc/fail2ban/jail.local << EOF
[DEFAULT]
bantime = 3600
findtime = 600
maxretry = 5

[sshd]
enabled = true
port = 22222
filter = sshd
logpath = /var/log/secure

[nginx-http-auth]
enabled = true
filter = nginx-http-auth
port = http,https
logpath = /var/log/nginx/error.log
EOF

# 启动Fail2ban
systemctl enable fail2ban
systemctl start fail2ban
```

### 7.2 应用安全配置

#### 7.2.1 Spring Security配置

```java
@Configuration
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Autowired
    private UserDetailsService userDetailsService;

    @Autowired
    private JwtAuthenticationEntryPoint jwtAuthenticationEntryPoint;

    @Autowired
    private JwtRequestFilter jwtRequestFilter;

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.csrf().disable()
            .authorizeRequests()
            .antMatchers("/api/auth/**").permitAll()
            .antMatchers("/api/articles/**", "/api/categories/**", "/api/contributors/**").permitAll()
            .antMatchers("/api/admin/**").hasRole("ADMIN")
            .anyRequest().authenticated()
            .and()
            .exceptionHandling().authenticationEntryPoint(jwtAuthenticationEntryPoint)
            .and()
            .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS);

        // 添加JWT过滤器
        http.addFilterBefore(jwtRequestFilter, UsernamePasswordAuthenticationFilter.class);
        
        // 添加XSS防护
        http.headers()
            .xssProtection()
            .and()
            .contentSecurityPolicy("default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; img-src 'self' data:; font-src 'self' data:; connect-src 'self'");
    }

    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.userDetailsService(userDetailsService).passwordEncoder(passwordEncoder());
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    @Override
    public AuthenticationManager authenticationManagerBean() throws Exception {
        return super.authenticationManagerBean();
    }
}
```

#### 7.2.2 HTTPS配置

```bash
# 使用Let's Encrypt获取SSL证书
yum install -y certbot python3-certbot-nginx

# 获取证书
certbot --nginx -d blog.example.com

# 自动续期证书
echo "0 0,12 * * * root python -c 'import random; import time; time.sleep(random.random() * 3600)' && certbot renew -q" | sudo tee -a /etc/crontab > /dev/null
```

### 7.3 数据安全

#### 7.3.1 MySQL数据加密

```sql
-- 创建加密函数
DELIMITER //
CREATE FUNCTION encrypt_data(p_data VARCHAR(255)) RETURNS VARBINARY(255)
BEGIN
    RETURN AES_ENCRYPT(p_data, 'encryption_key');
END //

CREATE FUNCTION decrypt_data(p_data VARBINARY(255)) RETURNS VARCHAR(255)
BEGIN
    RETURN AES_DECRYPT(p_data, 'encryption_key');
END //
DELIMITER ;

-- 使用加密函数存储敏感数据
UPDATE users SET email = encrypt_data(email) WHERE id = 1;

-- 使用解密函数读取敏感数据
SELECT id, username, decrypt_data(email) as email FROM users WHERE id = 1;
```

## 八、性能优化

### 8.1 前端性能优化

#### 8.1.1 Webpack优化配置

```javascript
// vue.config.js
module.exports = {
  productionSourceMap: false,
  configureWebpack: {
    optimization: {
      splitChunks: {
        chunks: 'all',
        minSize: 30000,
        maxSize: 250000,
        cacheGroups: {
          vendors: {
            name: 'chunk-vendors',
            test: /[\\/]node_modules[\\/]/,
            priority: -10,
            chunks: 'initial'
          },
          common: {
            name: 'chunk-common',
            minChunks: 2,
            priority: -20,
            chunks: 'initial',
            reuseExistingChunk: true
          }
        }
      }
    }
  },
  chainWebpack: config => {
    // 压缩图片
    config.module
      .rule('images')
      .use('image-webpack-loader')
      .loader('image-webpack-loader')
      .options({
        bypassOnDebug: true
      })
      .end();
      
    // 启用gzip压缩
    if (process.env.NODE_ENV === 'production') {
      config
        .plugin('compression')
        .use('compression-webpack-plugin')
        .tap(args => {
          return [{
            algorithm: 'gzip',
            test: /\.js$|\.html$|\.css$|\.svg$/,
            threshold: 10240,
            minRatio: 0.8
          }];
        });
    }
  }
};
```

#### 8.1.2 Nginx性能优化

```nginx
# nginx.conf
user nginx;
worker_processes auto;

error_log /var/log/nginx/error.log warn;
pid /var/run/nginx.pid;

events {
    worker_connections 1024;
    multi_accept on;
    use epoll;
}

http {
    include /etc/nginx/mime.types;
    default_type application/octet-stream;
    
    log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                    '$status $body_bytes_sent "$http_referer" '
                    '"$http_user_agent" "$http_x_forwarded_for"';
    
    access_log /var/log/nginx/access.log main;
    
    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    keepalive_timeout 65;
    types_hash_max_size 2048;
    server_tokens off;
    
    # 启用gzip压缩
    gzip on;
    gzip_vary on;
    gzip_proxied any;
    gzip_comp_level 6;
    gzip_buffers 16 8k;
    gzip_http_version 1.1;
    gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;
    
    # 文件缓存配置
    open_file_cache max=1000 inactive=20s;
    open_file_cache_valid 30s;
    open_file_cache_min_uses 2;
    open_file_cache_errors on;
    
    # 包含其他配置文件
    include /etc/nginx/conf.d/*.conf;
}
```

### 8.2 后端性能优化

#### 8.2.1 JVM优化

```bash
# 设置JVM参数
JAVA_OPTS="-Xms1g -Xmx2g -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=256m -XX:+UseG1GC -XX:MaxGCPauseMillis=200 -XX:ParallelGCThreads=4 -XX:ConcGCThreads=2 -XX:InitiatingHeapOccupancyPercent=70 -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/opt/blog/backend/logs/heapdump.hprof -XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:/opt/blog/backend/logs/gc.log -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=10 -XX:GCLogFileSize=100M"
```

#### 8.2.2 数据库优化

```sql
-- 添加索引
CREATE INDEX idx_article_category_id ON article(category_id);
CREATE INDEX idx_article_create_time ON article(create_time);
CREATE INDEX idx_article_status ON article(status);

-- 优化查询
EXPLAIN SELECT a.*, c.name as category_name 
FROM article a 
LEFT JOIN category c ON a.category_id = c.id 
WHERE a.status = 1 
ORDER BY a.create_time DESC 
LIMIT 10;
```

#### 8.2.3 Redis缓存优化

```java
@Service
public class ArticleServiceImpl implements ArticleService {

    @Autowired
    private ArticleRepository articleRepository;
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    private static final String CACHE_KEY_ARTICLE = "article:";
    private static final String CACHE_KEY_ARTICLES = "articles";
    private static final long CACHE_TTL = 3600; // 1小时
    
    @Override
    public ArticleDTO findById(Long id) {
        String cacheKey = CACHE_KEY_ARTICLE + id;
        
        // 尝试从缓存获取
        ArticleDTO cachedArticle = (ArticleDTO) redisTemplate.opsForValue().get(cacheKey);
        if (cachedArticle != null) {
            return cachedArticle;
        }
        
        // 缓存未命中，从数据库获取
        Article article = articleRepository.findById(id)
                .orElseThrow(() -> new BusinessException("Article not found"));
        
        // 转换为DTO
        ArticleDTO articleDTO = convertToDTO(article);
        
        // 存入缓存
        redisTemplate.opsForValue().set(cacheKey, articleDTO, CACHE_TTL, TimeUnit.SECONDS);
        
        return articleDTO;
    }
    
    @Override
    public Page<ArticleDTO> findAll(Pageable pageable) {
        String cacheKey = CACHE_KEY_ARTICLES + ":" + pageable.getPageNumber() + ":" + pageable.getPageSize();
        
        // 尝试从缓存获取
        Page<ArticleDTO> cachedArticles = (Page<ArticleDTO>) redisTemplate.opsForValue().get(cacheKey);
        if (cachedArticles != null) {
            return cachedArticles;
        }
        
        // 缓存未命中，从数据库获取
        Page<Article> articlePage = articleRepository.findAllByStatusOrderByCreateTimeDesc(1, pageable);
        Page<ArticleDTO> articleDTOPage = articlePage.map(this::convertToDTO);
        
        // 存入缓存
        redisTemplate.opsForValue().set(cacheKey, articleDTOPage, CACHE_TTL, TimeUnit.SECONDS);
        
        return articleDTOPage;
    }
    
    @Override
    @Transactional
    @CacheEvict(value = {CACHE_KEY_ARTICLE, CACHE_KEY_ARTICLES}, allEntries = true)
    public ArticleDTO save(ArticleDTO articleDTO) {
        // 保存文章逻辑
        // ...
        
        // 清除缓存由@CacheEvict注解处理
        return savedArticleDTO;
    }
    
    private ArticleDTO convertToDTO(Article article) {
        // 转换逻辑
        // ...
        return articleDTO;
    }
}
```

## 九、灾难恢复

### 9.1 灾难恢复计划

#### 9.1.1 风险评估

| 风险类型 | 影响程度 | 发生概率 | 应对策略 |
|---------|---------|---------|----------|
| 服务器硬件故障 | 高 | 中 | 使用云服务器，配置自动迁移 |
| 数据库故障 | 高 | 低 | 配置主从复制，定期备份 |
| 网络故障 | 中 | 中 | 使用多线路接入，配置负载均衡 |
| 应用程序故障 | 中 | 中 | 完善监控告警，自动重启服务 |
| 自然灾害 | 高 | 低 | 跨区域备份，异地容灾 |
| 人为操作失误 | 中 | 高 | 权限控制，操作审计，定期培训 |
| 恶意攻击 | 高 | 中 | 安全防护，入侵检测，定期安全审计 |

#### 9.1.2 恢复目标

- 恢复点目标（RPO）：不超过24小时的数据丢失
- 恢复时间目标（RTO）：关键服务4小时内恢复，完整服务24小时内恢复

#### 9.1.3 恢复策略

1. **服务器故障恢复**：
   - 使用云服务器的快照或镜像功能恢复系统
   - 从备份恢复应用程序和配置文件

2. **数据库故障恢复**：
   - 如果有从库，将从库提升为主库
   - 如果主从都故障，从最近的备份恢复数据库

3. **应用程序故障恢复**：
   - 回滚到上一个稳定版本
   - 从备份恢复配置文件

4. **完全灾难恢复**：
   - 在新的基础设施上重建系统
   - 从备份恢复数据和配置

### 9.2 恢复演练

每季度进行一次灾难恢复演练，包括以下场景：

1. 服务器故障恢复演练
2. 数据库故障恢复演练
3. 应用程序故障恢复演练

演练后编写报告，评估恢复效果，优化恢复流程。

## 十、运维文档

### 10.1 日常运维操作

#### 10.1.1 服务启停操作

```bash
# 启动服务
systemctl start nginx
systemctl start blog-backend
systemctl start mysqld
systemctl start redis

# 停止服务
systemctl stop blog-backend
systemctl stop nginx
systemctl stop redis
systemctl stop mysqld

# 重启服务
systemctl restart blog-backend
systemctl restart nginx

# 查看服务状态
systemctl status blog-backend
systemctl status nginx
systemctl status mysqld
systemctl status redis
```

#### 10.1.2 日志查看

```bash
# 查看应用日志
tail -f /opt/blog/backend/logs/application.log

# 查看Nginx访问日志
tail -f /var/log/nginx/blog.access.log

# 查看Nginx错误日志
tail -f /var/log/nginx/blog.error.log

# 查看MySQL错误日志
tail -f /var/log/mysql/mysql-error.log

# 查看系统日志
journalctl -u blog-backend -f
```

#### 10.1.3 系统监控

```bash
# 查看系统资源使用情况
top
htop

# 查看磁盘使用情况
df -h
du -sh /var/www/blog

# 查看内存使用情况
free -m

# 查看网络连接
netstat -tunlp

# 查看进程
ps -ef | grep java
ps -ef | grep nginx
```

### 10.2 常见问题处理

#### 10.2.1 应用无法访问

1. 检查服务状态
```bash
systemctl status blog-backend
systemctl status nginx
```

2. 检查网络连接
```bash
netstat -tunlp | grep 8081
netstat -tunlp | grep 80
```

3. 检查防火墙设置
```bash
firewall-cmd --list-all
```

4. 检查日志
```bash
tail -f /opt/blog/backend/logs/application.log
tail -f /var/log/nginx/error.log
```

5. 重启服务
```bash
systemctl restart blog-backend
systemctl restart nginx
```

#### 10.2.2 数据库连接问题

1. 检查数据库服务状态
```bash
systemctl status mysqld
```

2. 检查数据库连接
```bash
mysql -u bloguser -p -e "SELECT 1;"
```

3. 检查数据库连接配置
```bash
cat /opt/blog/backend/config/application-prod.yml | grep datasource -A 10
```

4. 检查数据库日志
```bash
tail -f /var/log/mysql/mysql-error.log
```

#### 10.2.3 性能问题处理

1. 检查系统负载
```bash
top
uptime
```

2. 检查内存使用
```bash
free -m
```

3. 检查磁盘IO
```bash
iotop
```

4. 检查慢查询
```bash
mysql -u root -p -e "SELECT * FROM mysql.slow_log LIMIT 10;"
```

5. 检查JVM状态
```bash
jstat -gcutil $(pgrep java) 1000 10
```

### 10.3 系统升级流程

#### 10.3.1 前端升级流程

1. 备份当前版本
```bash
cp -r /var/www/blog /var/www/blog.bak.$(date +"%Y%m%d")
```

2. 部署新版本
```bash
# 构建新版本
cd /path/to/frontend-source
git pull
npm install
npm run build

# 部署新版本
cp -r dist/* /var/www/blog/
```

3. 验证新版本
```bash
# 检查网站是否正常访问
curl -I https://blog.example.com
```

4. 回滚（如果需要）
```bash
rm -rf /var/www/blog/*
cp -r /var/www/blog.bak.$(date +"%Y%m%d")/* /var/www/blog/
```

#### 10.3.2 后端升级流程

1. 备份当前版本
```bash
cp /opt/blog/backend/app.jar /opt/blog/backend/app.jar.bak.$(date +"%Y%m%d")
cp -r /opt/blog/backend/config /opt/blog/backend/config.bak.$(date +"%Y%m%d")
```

2. 部署新版本
```bash
# 构建新版本
cd /path/to/backend-source
git pull
mvn clean package -DskipTests

# 停止服务
systemctl stop blog-backend

# 部署新版本
cp target/blog-backend.jar /opt/blog/backend/app.jar

# 更新配置（如果需要）
# cp src/main/resources/application-prod.yml /opt/blog/backend/config/

# 启动服务
systemctl start blog-backend
```

3. 验证新版本
```bash
# 检查服务状态
systemctl status blog-backend

# 检查日志
tail -f /opt/blog/backend/logs/application.log

# 测试API
curl -I https://blog.example.com/api/articles
```

4. 回滚（如果需要）
```bash
# 停止服务
systemctl stop blog-backend

# 恢复备份
cp /opt/blog/backend/app.jar.bak.$(date +"%Y%m%d") /opt/blog/backend/app.jar
cp -r /opt/blog/backend/config.bak.$(date +"%Y%m%d")/* /opt/blog/backend/config/

# 启动服务
systemctl start blog-backend
```

## 十一、总结

本文档详细描述了博客系统的部署与运维方案，包括部署架构、环境配置、部署流程、监控策略、备份恢复、安全防护以及性能优化等内容。通过系统化的部署与运维措施，确保博客系统的稳定运行、高可用性和良好的用户体验。

运维团队应定期回顾和更新本文档，确保其与实际运维工作保持一致，并根据系统变化和新的最佳实践不断优化部署与运维方案。