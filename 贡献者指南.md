# 博客项目贡献者指南

## 一、欢迎

感谢您对我们博客项目的关注！我们非常欢迎各种形式的贡献，无论是代码贡献、文档改进、问题报告还是功能建议。本指南旨在帮助您了解如何有效地参与到项目中来，使您的贡献能够顺利地被接受和整合。

## 二、行为准则

### 2.1 基本原则

- **尊重他人**：尊重项目中的每一位参与者，无论其技术水平、经验或背景如何。
- **开放包容**：欢迎不同观点和建设性的批评，保持开放的心态。
- **专业沟通**：在交流中保持专业，避免人身攻击、歧视性言论或其他不当行为。
- **团队合作**：与其他贡献者合作，共同改进项目。

### 2.2 禁止行为

- 使用性别、种族、宗教等方面的歧视性言论
- 发布与项目无关的广告或宣传内容
- 人身攻击或侮辱性评论
- 其他任何不适合专业环境的行为

## 三、如何贡献

### 3.1 报告问题

如果您发现了bug或有改进建议，请通过以下步骤报告：

1. 检查现有的问题列表，确保您的问题尚未被报告
2. 使用问题模板创建新的问题报告
3. 提供尽可能详细的信息，包括：
   - 问题的简要描述
   - 复现步骤
   - 预期行为与实际行为
   - 环境信息（操作系统、浏览器版本等）
   - 相关的截图或日志

### 3.2 提交代码

#### 3.2.1 开发环境设置

```bash
# 克隆仓库
git clone https://github.com/username/blog-project.git
cd blog-project

# 前端环境设置
cd frontend
npm install

# 后端环境设置
cd ../backend
mvn install
```

#### 3.2.2 开发工作流

1. **创建分支**：从最新的主分支创建一个新的功能或修复分支
   ```bash
   git checkout main
   git pull
   git checkout -b feature/your-feature-name
   # 或者
   git checkout -b fix/issue-description
   ```

2. **编写代码**：在您的分支上进行开发，遵循项目的代码规范

3. **提交变更**：使用清晰的提交消息
   ```bash
   git add .
   git commit -m "feat: add new feature" # 或 "fix: resolve issue #123"
   ```

4. **保持同步**：定期从主分支拉取最新更改
   ```bash
   git checkout main
   git pull
   git checkout your-branch
   git rebase main
   ```

5. **推送变更**：将您的分支推送到远程仓库
   ```bash
   git push origin your-branch
   ```

6. **创建Pull Request**：在GitHub上创建一个新的Pull Request，详细描述您的更改

#### 3.2.3 代码审查

所有代码贡献都需要经过审查才能被合并。在代码审查过程中：

- 对审查者的反馈保持开放态度
- 及时响应评论和建议
- 如有必要，更新您的代码并推送新的更改

### 3.3 文档贡献

文档对于项目的可用性和可维护性至关重要。您可以通过以下方式贡献文档：

1. 改进现有文档：修正错误、更新过时信息或提高清晰度
2. 添加新文档：为未记录的功能或流程创建文档
3. 翻译文档：将文档翻译成其他语言

### 3.4 测试贡献

提高测试覆盖率对项目质量非常重要：

1. 为新功能编写测试
2. 为发现的bug编写回归测试
3. 改进现有测试

## 四、代码规范

### 4.1 前端代码规范

#### 4.1.1 JavaScript/Vue规范

- 使用ES6+语法
- 使用2空格缩进
- 使用单引号作为字符串引号
- 每行代码不超过100个字符
- 使用驼峰命名法（camelCase）命名变量和函数
- 使用PascalCase命名组件
- 组件属性顺序：props, data, computed, watch, methods, 生命周期钩子

```javascript
// 好的示例
const userName = 'John';

function calculateTotal(items) {
  return items.reduce((sum, item) => sum + item.price, 0);
}

// Vue组件示例
export default {
  name: 'ArticleCard',
  props: {
    article: {
      type: Object,
      required: true
    }
  },
  data() {
    return {
      isExpanded: false
    };
  },
  computed: {
    formattedDate() {
      return new Date(this.article.createdAt).toLocaleDateString();
    }
  },
  methods: {
    toggleExpand() {
      this.isExpanded = !this.isExpanded;
    }
  }
};
```

#### 4.1.2 CSS/SCSS规范

- 使用2空格缩进
- 使用连字符分隔的小写类名（kebab-case）
- 使用SCSS嵌套，但不超过3层
- 使用简写属性
- 按照布局属性、盒模型属性、文本属性、视觉属性的顺序组织CSS属性

```scss
// 好的示例
.article-card {
  // 布局属性
  display: flex;
  flex-direction: column;
  
  // 盒模型属性
  margin: 0 0 20px;
  padding: 15px;
  width: 100%;
  
  // 文本属性
  font-size: 16px;
  line-height: 1.5;
  
  // 视觉属性
  background-color: #ffffff;
  border-radius: 4px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  
  &__title {
    font-size: 20px;
    font-weight: bold;
    margin-bottom: 10px;
  }
  
  &__content {
    color: #333333;
  }
}
```

### 4.2 后端代码规范

#### 4.2.1 Java规范

- 使用4空格缩进
- 类名使用PascalCase
- 方法名和变量名使用camelCase
- 常量使用全大写，下划线分隔（UPPER_SNAKE_CASE）
- 每个类都应该有Javadoc注释
- 方法应该简洁，遵循单一职责原则
- 使用明确的异常处理

```java
/**
 * 文章服务实现类，负责文章的CRUD操作
 */
@Service
public class ArticleServiceImpl implements ArticleService {
    
    private static final int MAX_TITLE_LENGTH = 100;
    
    private final ArticleRepository articleRepository;
    private final CategoryRepository categoryRepository;
    
    @Autowired
    public ArticleServiceImpl(ArticleRepository articleRepository, 
                             CategoryRepository categoryRepository) {
        this.articleRepository = articleRepository;
        this.categoryRepository = categoryRepository;
    }
    
    /**
     * 创建新文章
     *
     * @param articleDTO 文章数据传输对象
     * @return 创建的文章
     * @throws BusinessException 如果标题超过最大长度或分类不存在
     */
    @Override
    @Transactional
    public ArticleDTO createArticle(ArticleDTO articleDTO) {
        // 验证标题长度
        if (articleDTO.getTitle().length() > MAX_TITLE_LENGTH) {
            throw new BusinessException("文章标题不能超过" + MAX_TITLE_LENGTH + "个字符");
        }
        
        // 验证分类是否存在
        Category category = categoryRepository.findById(articleDTO.getCategoryId())
                .orElseThrow(() -> new BusinessException("分类不存在"));
        
        // 转换DTO为实体
        Article article = convertToEntity(articleDTO);
        article.setCategory(category);
        article.setCreateTime(new Date());
        article.setUpdateTime(new Date());
        
        // 保存文章
        Article savedArticle = articleRepository.save(article);
        
        // 返回DTO
        return convertToDTO(savedArticle);
    }
    
    // 其他方法...
    
    private Article convertToEntity(ArticleDTO dto) {
        // 转换逻辑
    }
    
    private ArticleDTO convertToDTO(Article entity) {
        // 转换逻辑
    }
}
```

#### 4.2.2 API设计规范

- 使用RESTful设计原则
- 使用复数名词表示资源集合（如/articles而不是/article）
- 使用HTTP方法表示操作（GET、POST、PUT、DELETE）
- 使用HTTP状态码表示结果
- 使用查询参数进行过滤、排序和分页
- 版本化API（如/api/v1/articles）

```java
@RestController
@RequestMapping("/api/v1/articles")
public class ArticleController {
    
    private final ArticleService articleService;
    
    @Autowired
    public ArticleController(ArticleService articleService) {
        this.articleService = articleService;
    }
    
    @GetMapping
    public ResponseEntity<Page<ArticleDTO>> getAllArticles(
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "10") int size,
            @RequestParam(required = false) String keyword,
            @RequestParam(required = false) Long categoryId) {
        
        Pageable pageable = PageRequest.of(page, size, Sort.by("createTime").descending());
        Page<ArticleDTO> articles = articleService.findArticles(keyword, categoryId, pageable);
        
        return ResponseEntity.ok(articles);
    }
    
    @GetMapping("/{id}")
    public ResponseEntity<ArticleDTO> getArticleById(@PathVariable Long id) {
        ArticleDTO article = articleService.findById(id);
        return ResponseEntity.ok(article);
    }
    
    @PostMapping
    public ResponseEntity<ArticleDTO> createArticle(@Valid @RequestBody ArticleDTO articleDTO) {
        ArticleDTO createdArticle = articleService.createArticle(articleDTO);
        return ResponseEntity
                .created(URI.create("/api/v1/articles/" + createdArticle.getId()))
                .body(createdArticle);
    }
    
    @PutMapping("/{id}")
    public ResponseEntity<ArticleDTO> updateArticle(
            @PathVariable Long id, 
            @Valid @RequestBody ArticleDTO articleDTO) {
        
        articleDTO.setId(id);
        ArticleDTO updatedArticle = articleService.updateArticle(articleDTO);
        return ResponseEntity.ok(updatedArticle);
    }
    
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteArticle(@PathVariable Long id) {
        articleService.deleteArticle(id);
        return ResponseEntity.noContent().build();
    }
}
```

### 4.3 数据库规范

- 表名使用小写，下划线分隔（snake_case）
- 主键命名为id
- 外键命名为{table_name}_id
- 使用created_at和updated_at记录创建和更新时间
- 使用is_前缀命名布尔字段
- 为所有表添加适当的索引
- 使用合适的字段类型和长度

```sql
CREATE TABLE article (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    title VARCHAR(100) NOT NULL,
    content TEXT NOT NULL,
    summary VARCHAR(200),
    category_id BIGINT NOT NULL,
    author_id BIGINT NOT NULL,
    view_count INT DEFAULT 0,
    is_published BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (category_id) REFERENCES category(id),
    FOREIGN KEY (author_id) REFERENCES user(id),
    INDEX idx_category (category_id),
    INDEX idx_author (author_id),
    INDEX idx_created_at (created_at)
);
```

## 五、提交规范

### 5.1 Git提交消息规范

我们使用[Conventional Commits](https://www.conventionalcommits.org/)规范来格式化提交消息：

```
<type>[optional scope]: <description>

[optional body]

[optional footer(s)]
```

类型（type）必须是以下之一：

- **feat**: 新功能
- **fix**: 修复bug
- **docs**: 文档更改
- **style**: 不影响代码含义的更改（空格、格式化、缺少分号等）
- **refactor**: 既不修复bug也不添加功能的代码更改
- **perf**: 改进性能的代码更改
- **test**: 添加或修正测试
- **build**: 影响构建系统或外部依赖的更改
- **ci**: 更改CI配置文件和脚本
- **chore**: 其他不修改src或test文件的更改

示例：

```
feat(article): add pagination to article list

Implement pagination for the article list to improve performance with large datasets.

Closes #123
```

### 5.2 Pull Request规范

- 每个PR应该专注于一个特定的功能或修复
- PR标题应遵循与提交消息相同的规范
- PR描述应包含以下内容：
  - 更改的目的
  - 实现方法的简要说明
  - 测试方法
  - 相关的问题链接
- 在提交PR之前，确保所有测试都通过
- 确保代码符合项目的代码规范

## 六、测试指南

### 6.1 前端测试

#### 6.1.1 单元测试

使用Jest和Vue Test Utils进行组件单元测试：

```javascript
import { shallowMount } from '@vue/test-utils';
import ArticleCard from '@/components/ArticleCard.vue';

describe('ArticleCard.vue', () => {
  it('renders article title correctly', () => {
    const article = {
      id: 1,
      title: 'Test Article',
      summary: 'This is a test article',
      createdAt: '2023-01-01T00:00:00Z'
    };
    
    const wrapper = shallowMount(ArticleCard, {
      propsData: { article }
    });
    
    expect(wrapper.find('.article-card__title').text()).toBe('Test Article');
  });
  
  it('emits click event when article is clicked', async () => {
    const article = {
      id: 1,
      title: 'Test Article',
      summary: 'This is a test article',
      createdAt: '2023-01-01T00:00:00Z'
    };
    
    const wrapper = shallowMount(ArticleCard, {
      propsData: { article }
    });
    
    await wrapper.find('.article-card').trigger('click');
    
    expect(wrapper.emitted().click).toBeTruthy();
    expect(wrapper.emitted().click[0]).toEqual([article.id]);
  });
});
```

#### 6.1.2 端到端测试

使用Cypress进行端到端测试：

```javascript
describe('Article List', () => {
  beforeEach(() => {
    cy.visit('/articles');
  });
  
  it('displays a list of articles', () => {
    cy.get('.article-card').should('have.length.at.least', 1);
  });
  
  it('navigates to article detail when article is clicked', () => {
    cy.get('.article-card').first().click();
    cy.url().should('include', '/articles/');
    cy.get('.article-detail').should('be.visible');
  });
  
  it('filters articles when search is used', () => {
    const searchTerm = 'test';
    cy.get('.search-input').type(searchTerm);
    cy.get('.search-button').click();
    
    cy.get('.article-card').each(($card) => {
      cy.wrap($card).should('contain.text', searchTerm);
    });
  });
});
```

### 6.2 后端测试

#### 6.2.1 单元测试

使用JUnit和Mockito进行单元测试：

```java
@ExtendWith(MockitoExtension.class)
public class ArticleServiceTest {
    
    @Mock
    private ArticleRepository articleRepository;
    
    @Mock
    private CategoryRepository categoryRepository;
    
    @InjectMocks
    private ArticleServiceImpl articleService;
    
    @Test
    public void testCreateArticle_Success() {
        // 准备测试数据
        ArticleDTO articleDTO = new ArticleDTO();
        articleDTO.setTitle("Test Article");
        articleDTO.setContent("Test Content");
        articleDTO.setCategoryId(1L);
        
        Category category = new Category();
        category.setId(1L);
        category.setName("Test Category");
        
        Article article = new Article();
        article.setId(1L);
        article.setTitle("Test Article");
        article.setContent("Test Content");
        article.setCategory(category);
        
        // 设置Mock行为
        when(categoryRepository.findById(1L)).thenReturn(Optional.of(category));
        when(articleRepository.save(any(Article.class))).thenReturn(article);
        
        // 执行测试
        ArticleDTO result = articleService.createArticle(articleDTO);
        
        // 验证结果
        assertNotNull(result);
        assertEquals(1L, result.getId());
        assertEquals("Test Article", result.getTitle());
        assertEquals("Test Content", result.getContent());
        assertEquals(1L, result.getCategoryId());
        
        // 验证交互
        verify(categoryRepository).findById(1L);
        verify(articleRepository).save(any(Article.class));
    }
    
    @Test
    public void testCreateArticle_CategoryNotFound() {
        // 准备测试数据
        ArticleDTO articleDTO = new ArticleDTO();
        articleDTO.setTitle("Test Article");
        articleDTO.setContent("Test Content");
        articleDTO.setCategoryId(1L);
        
        // 设置Mock行为
        when(categoryRepository.findById(1L)).thenReturn(Optional.empty());
        
        // 执行测试并验证异常
        BusinessException exception = assertThrows(BusinessException.class, () -> {
            articleService.createArticle(articleDTO);
        });
        
        assertEquals("分类不存在", exception.getMessage());
        
        // 验证交互
        verify(categoryRepository).findById(1L);
        verify(articleRepository, never()).save(any(Article.class));
    }
}
```

#### 6.2.2 集成测试

使用Spring Boot Test进行集成测试：

```java
@SpringBootTest
@AutoConfigureMockMvc
public class ArticleControllerIntegrationTest {
    
    @Autowired
    private MockMvc mockMvc;
    
    @Autowired
    private ObjectMapper objectMapper;
    
    @MockBean
    private ArticleService articleService;
    
    @Test
    public void testGetAllArticles() throws Exception {
        // 准备测试数据
        List<ArticleDTO> articles = Arrays.asList(
            new ArticleDTO(1L, "Article 1", "Content 1", 1L),
            new ArticleDTO(2L, "Article 2", "Content 2", 1L)
        );
        
        Page<ArticleDTO> articlePage = new PageImpl<>(articles);
        
        // 设置Mock行为
        when(articleService.findArticles(any(), any(), any()))
            .thenReturn(articlePage);
        
        // 执行测试
        mockMvc.perform(get("/api/v1/articles")
                .contentType(MediaType.APPLICATION_JSON))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.content", hasSize(2)))
                .andExpect(jsonPath("$.content[0].id").value(1))
                .andExpect(jsonPath("$.content[0].title").value("Article 1"))
                .andExpect(jsonPath("$.content[1].id").value(2))
                .andExpect(jsonPath("$.content[1].title").value("Article 2"));
        
        // 验证交互
        verify(articleService).findArticles(any(), any(), any());
    }
    
    @Test
    public void testCreateArticle() throws Exception {
        // 准备测试数据
        ArticleDTO articleDTO = new ArticleDTO(null, "New Article", "New Content", 1L);
        ArticleDTO createdArticle = new ArticleDTO(1L, "New Article", "New Content", 1L);
        
        // 设置Mock行为
        when(articleService.createArticle(any(ArticleDTO.class)))
            .thenReturn(createdArticle);
        
        // 执行测试
        mockMvc.perform(post("/api/v1/articles")
                .contentType(MediaType.APPLICATION_JSON)
                .content(objectMapper.writeValueAsString(articleDTO)))
                .andExpect(status().isCreated())
                .andExpect(header().string("Location", "/api/v1/articles/1"))
                .andExpect(jsonPath("$.id").value(1))
                .andExpect(jsonPath("$.title").value("New Article"))
                .andExpect(jsonPath("$.content").value("New Content"));
        
        // 验证交互
        verify(articleService).createArticle(any(ArticleDTO.class));
    }
}
```

## 七、文档指南

### 7.1 代码注释

#### 7.1.1 前端代码注释

- 为组件添加简要描述
- 为复杂的方法添加注释
- 为props添加类型和描述
- 使用JSDoc风格的注释

```javascript
/**
 * 文章卡片组件 - 显示文章的摘要信息
 * @component
 */
export default {
  name: 'ArticleCard',
  
  props: {
    /**
     * 文章对象
     * @type {Object}
     * @property {Number} id - 文章ID
     * @property {String} title - 文章标题
     * @property {String} summary - 文章摘要
     * @property {String} createdAt - 创建时间
     */
    article: {
      type: Object,
      required: true
    },
    
    /**
     * 是否显示详细信息
     * @type {Boolean}
     */
    showDetails: {
      type: Boolean,
      default: false
    }
  },
  
  methods: {
    /**
     * 处理文章点击事件
     * 触发click事件并传递文章ID
     */
    handleClick() {
      this.$emit('click', this.article.id);
    },
    
    /**
     * 格式化日期为本地字符串
     * @param {String} dateString - ISO格式的日期字符串
     * @returns {String} 格式化后的日期字符串
     */
    formatDate(dateString) {
      return new Date(dateString).toLocaleDateString();
    }
  }
};
```

#### 7.1.2 后端代码注释

- 为类添加Javadoc注释
- 为公共方法添加Javadoc注释
- 为复杂的私有方法添加注释
- 为异常情况添加注释

```java
/**
 * 文章服务接口的实现类，提供文章的CRUD操作
 */
@Service
public class ArticleServiceImpl implements ArticleService {
    
    private final ArticleRepository articleRepository;
    private final CategoryRepository categoryRepository;
    
    /**
     * 构造函数，通过依赖注入初始化仓库
     *
     * @param articleRepository 文章仓库
     * @param categoryRepository 分类仓库
     */
    @Autowired
    public ArticleServiceImpl(ArticleRepository articleRepository, 
                             CategoryRepository categoryRepository) {
        this.articleRepository = articleRepository;
        this.categoryRepository = categoryRepository;
    }
    
    /**
     * 根据ID查找文章
     *
     * @param id 文章ID
     * @return 文章DTO对象
     * @throws BusinessException 如果文章不存在
     */
    @Override
    public ArticleDTO findById(Long id) {
        Article article = articleRepository.findById(id)
                .orElseThrow(() -> new BusinessException("文章不存在"));
        
        return convertToDTO(article);
    }
    
    /**
     * 将文章实体转换为DTO
     *
     * @param article 文章实体
     * @return 文章DTO
     */
    private ArticleDTO convertToDTO(Article article) {
        ArticleDTO dto = new ArticleDTO();
        dto.setId(article.getId());
        dto.setTitle(article.getTitle());
        dto.setContent(article.getContent());
        dto.setSummary(article.getSummary());
        dto.setCategoryId(article.getCategory().getId());
        dto.setCategoryName(article.getCategory().getName());
        dto.setCreatedAt(article.getCreatedAt());
        dto.setUpdatedAt(article.getUpdatedAt());
        
        return dto;
    }
}
```

### 7.2 项目文档

项目应包含以下文档：

1. **README.md**：项目概述、安装说明、使用指南
2. **CONTRIBUTING.md**：贡献指南（本文档）
3. **API文档**：使用Swagger或其他工具生成的API文档
4. **架构文档**：描述系统架构和组件关系
5. **数据库文档**：数据库模式和关系

## 八、发布流程

### 8.1 版本控制

我们使用[语义化版本控制](https://semver.org/)：

- **主版本号**：当进行不兼容的API更改时
- **次版本号**：当以向后兼容的方式添加功能时
- **修订号**：当进行向后兼容的bug修复时

### 8.2 发布流程

1. **准备发布**：
   - 确保所有测试通过
   - 更新版本号
   - 更新CHANGELOG.md

2. **创建发布分支**：
   ```bash
   git checkout -b release/v1.0.0
   ```

3. **最终测试**：
   - 在发布分支上进行最终测试
   - 修复任何发现的问题

4. **合并到主分支**：
   ```bash
   git checkout main
   git merge release/v1.0.0
   ```

5. **创建标签**：
   ```bash
   git tag -a v1.0.0 -m "Release version 1.0.0"
   git push origin v1.0.0
   ```

6. **部署**：
   - 部署到生产环境
   - 监控部署过程

7. **发布公告**：
   - 在GitHub上创建发布说明
   - 通知用户和贡献者

## 九、社区互动

### 9.1 沟通渠道

- **问题跟踪**：GitHub Issues
- **讨论**：GitHub Discussions
- **实时聊天**：Discord或Slack频道

### 9.2 获取帮助

如果您在贡献过程中需要帮助，可以：

1. 查阅项目文档
2. 在GitHub Discussions中提问
3. 在相关Issue中评论
4. 联系项目维护者

## 十、致谢

感谢所有为本项目做出贡献的人！您的时间和专业知识对我们非常宝贵。

---

本指南将随着项目的发展而更新。如果您有任何建议或问题，请随时提出Issue或Pull Request。